# 双指针

[toc]



------

## 快慢指针

### [LC141. 环形链表: 判断链表中是否有环](https://leetcode-cn.com/problems/linked-list-cycle/)

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。



示例 1：

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="width:50%;" />

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img" style="width:25%;" />

输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。

示例 3：

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img" style="width:12.5%;" />

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。

提示：**pos可忽略，按照链表的特性去做题即可**

函数签名：

```java
public boolean hasCycle(ListNode head);
```



#### **思路**

用两个指针，一个跑得快，一个跑得慢。

​		如果不含有环，跑得快的那个指针最终会遇到 `null`，说明链表不含环；

​		如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。

#### <u>**Solution**</u>

```java
		public boolean hasCycle(ListNode head) {
        ListNode slow = head, fast = head;
        //fast.next!=null是为了防止NullPointerException
      	//要确保fast、fast.next都不为null才能访问fast.next.next
        while(fast!=null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
            if(fast==slow)
                return true;
        }
        return false;
    }
```

### [LC142. 环形链表 II: 返回链表开始入环的第一个节点；如果链表无环，则返回 null](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

函数签名：

```java
public ListNode detectCycle(ListNode head);
```

**`当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。`**下面的解释看不懂就记结论！

第一次相遇时，假设慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步。**这多走的** **`k`** **步其实就是** **`fast`** **指针在环里转圈圈，所以** **`k`** **的值就是环长度的「整数倍」**。

设相遇点距环的起点的距离为 `m`，那么环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。

巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点。你甭管 `fast` 在环里到底转了几圈，反正走 `k` 步可以到相遇点，那走 `k - m` 步一定就是走到环起点了：

<img src="imgs/image-20210721133159863.png" alt="image-20210721133159863" style="width:50%;" />

所以，只要我们把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，`k - m` 步后就会相遇，相遇之处就是环的起点了。

#### <u>**Solution**</u>

```java
		public ListNode detectCycle(ListNode head) {
        ListNode slow = head, fast = head;
      	//fast.next!=null是为了防止NullPointerException
      	//要确保fast、fast.next都不为null才能访问fast.next.next
        while(fast!=null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
            if(fast==slow)
                break;
        }
        
        if(fast==null || fast.next==null)
        // fast 遇到空指针说明没有环
            return null;

        slow = head;
        while(slow!=fast){
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
```

### [LC876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

给定一个头结点为 head 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回**第二个中间结点**。

示例 1：

输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
示例 2：

输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。

函数签名：

```java
public ListNode middleNode(ListNode head);
```



#### <u>**Solution**</u>

如果链表无环（非空单链表即表示无环），则可用快慢指针的方法，快指针速度是慢指针的2倍；

快指针走完时，慢指针正好走到链表的中间位置（node总数为奇数）；

如果长度是偶数，`slow` 最终的位置是中间偏右，因为null也占一位，slow会多走一位

<img src="imgs/image-20210721135002776.png" alt="image-20210721135002776" style="width:75%;" />

图中left即为slow

```java
		public ListNode middleNode(ListNode head) {
        ListNode fast, slow;
        fast = slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
    // slow 就在中间位置
    return slow;
    }
```

### [LC19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

进阶：你能尝试使用一趟扫描实现吗？

 示例 1：

<img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img" style="width:50%;" />

输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]

示例 2：

输入：head = [1], n = 1
输出：[]

示例 3：

输入：head = [1,2], n = 1
输出：[1]

函数签名：

```java
public ListNode removeNthFromEnd(ListNode head, int n);
```



#### 思路

让快指针先走 `n` 步：

如果n步后走到null，说明倒数第 n 个节点就是第一个节点；

如果n步后快指针没走到头，快慢指针开始同速前进。这样当快指针走到链表末尾 `null` 时，慢指针所在的位置就是倒数第 `n` 个链表节点（`n` 不会超过链表长度）。

#### Solution

```java
		public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fast = head, slow = head;
        while(n>0){
            fast = fast.next;
            n--;
        }

        // 如果此时快指针走到头了，说明倒数第 n 个节点就是第一个节点
        if(fast==null)
            return head.next;
        
        // 让慢指针和快指针同步向前
        while(fast!=null && fast.next!=null){//fast.next!=null是为了防止slow多走一位
            slow = slow.next;
            fast = fast.next;
        }
        // slow.next 就是倒数第 n 个节点，删除它
        slow.next = slow.next.next;
        return head;
    }
```



## 左右指针

左右指针在数组中实际是指两个索引值，一般初始化为 `left = 0, right = nums.length - 1` 。

### [Binary Search二分查找](./binarySearch.md)

### [LC167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。

函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。

你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。


示例 1：

输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
示例 2：

输入：numbers = [2,3,4], target = 6
输出：[1,3]
示例 3：

输入：numbers = [-1,0], target = -1
输出：[1,2]

函数签名：

```java
public int[] twoSum(int[] numbers, int target);
```



#### 思路

left在数组头，right在数组尾，向中间查找;

#### Solution

```java
		public int[] twoSum(int[] numbers, int target) {
        int left = 0, right = numbers.length-1;
        //left!=right因为要返回两个不同数
        while(left<right){
            int sum = numbers[left] + numbers[right];
            if(sum==target)
                // 题目要求的索引是从 1 开始的
                return new int[]{left+1, right+1};
            else if(sum>target)
                right = right - 1;// 让 sum 小一点
            else if(sum<target)
                left = left + 1;// 让 sum 大一点
        }
        return new int[]{-1,-1};
    }
```

### [LC344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须**原地**修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

 示例 1：

输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]

示例 2：

输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]

函数签名：

```java
public void reverseString(char[] s);
```

#### Solution

以mid为中轴，对换元素即可

```java
		public void reverseString(char[] s) {
        int left = 0, right = s.length - 1;
        while(left<right){
            char tmp = s[left];
            s[left] = s[right];
            s[right] = tmp;
            left++;
            right--;
        }
    }
```

### [LC870. 优势洗牌 aka田忌赛马](https://leetcode-cn.com/problems/advantage-shuffle/)

给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] > B[i] 的索引 i 的数目来描述。

返回 A 的任意排列，使其相对于 B 的优势最大化，**尽可能多的让** **`A[i] > B[i]`**。

示例 1：

输入：A = [2,7,11,15], B = [1,10,4,11]
输出：[2,11,7,15]

示例 2：

输入：A = [12,24,8,32], B = [13,25,32,11]
输出：[24,32,8,12]

函数签名：

```java
public int[] advantageCount(int[] nums1, int[] nums2);
```

#### Solution

将齐王和田忌的马按照战斗力排序，然后按照排名一一对比。如果田忌的马能赢，那就比赛，如果赢不了，那就换个垫底的来送人头，保存实力。

```java
		//PriorityQueue用法：
    //https://www.cnblogs.com/wei-jing/p/10806236.html
    //https://www.cnblogs.com/Elliott-Su-Faith-change-our-life/p/7472265.html
    // Comparator<int[]> cmp = new Comparator<int[]>() {
    //     public int compare(int[] num2IdxAndVal1, int[] num2IdxAndVal2) {
    //         //升序
    //         //return num2IdxAndVal1[1] - num2IdxAndVal2[1];
    //         //降序
    //         return num2IdxAndVal2[1] - num2IdxAndVal1[1];
    //     }
    // };
    public int[] advantageCount(int[] nums1, int[] nums2) {
        PriorityQueue<int[]> num2MaxPQ = new PriorityQueue<>(
            (int[] num2IdxAndVal1, int[] num2IdxAndVal2) -> { 
                //idxAndVal[0]是nums2的索引i
                //idxAndVal[1]是nums2[i]的值
                //这里是给PQ<int[]>按照idxAndVal[1]的值降序排序
                //此方法相当于上面注释掉的cmp方法
                return num2IdxAndVal2[1] - num2IdxAndVal1[1];
        }
        );
        //给nums2从大到小降序排序
        for(int i=0; i<nums2.length; i++)
            num2MaxPQ.offer(new int[]{i, nums2[i]});

        //给nums1从小到大升序排序
        Arrays.sort(nums1);
        //左边最小，右边最大
        int num1Left = 0, num1Right = nums1.length-1;
        int[] res = new int[nums1.length];
        while(!num2MaxPQ.isEmpty()){
            int[] num2IdxAndVal = num2MaxPQ.poll();
            //num2中最大值的索引
            int num2Idx = num2IdxAndVal[0];
            //num2中的最大值
            int num2Val = num2IdxAndVal[1];
            
            if(nums1[num1Right]>num2Val){
                //num1的最大值nums1[num1Right]能比过num2的最大值num2Val,就自己上
                res[num2Idx] = nums1[num1Right];
                num1Right--;
            } else {
                //num1的最大值nums1[num1Right]不能比过num2的最大值num2Val,就找最垃圾的混一下
                res[num2Idx] = nums1[num1Left];
                num1Left++;
            }
        }
        return res;
    }
```

