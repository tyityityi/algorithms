# 黑盒白盒

## 黑盒测试：

也称**功能测试**或**数据驱动测试**，它是在已知产品所应具有的功能，通过测试来检测每个功能是否都能正常使用，在测试时，把程序看作一个**不能打开的黑盒子**，在完全**不考虑程序内部结构和内部特性**的情况下，测试者在程序接口进行测试，它只检查程序**功能是否按照需求规格说明书的规定**正常使用，程序是否能**正确地接收输入数锯并产生正确的输出信息**，并且**保持外部信息（如数据库或文件）的完整性**。

“黑盒”法着眼于程序外部结构、不考虑内部逻辑结构、针对软件界面和软件功能进行测试。“黑盒”法是**穷举输入测试**，只有把所有可能的输入都作为测试情况使用，才能以这种方法查出程序中所有的错误。实际上测试情况有无穷多个，因此**不仅要测试所有合法的输入，还要对不合法但是可能的输入进行测试**。

### 1.等价类划分法

等价类划分是将系统的**输入域划分为若干部分**，然后从每个部分选取少量代表性数据进行测试。等价类可以划分为有效等价类和无效等价类，设计测试用例的时候要考虑这两种等价类。

### 2.边界值分析法

边界值分析法是对等价类划分的一种**补充**，因为大多数错误都在输入输出的边界上。边界值分析就是假定大多数错误出现在输入条件的边界上，如果边界附件取值不会导致程序出错，那么其他取值出错的可能性也就很小。

边界值分析法是通过**优先选择不同等价类间的边界值**覆盖有效等价类和无效等价类来更有效的进行测试，因此该方法要和等价类划分法结合使用。

### 3.正交试验法

正交是从大量的试验点中挑选出适量的、有代表性的点。正交试验设计是研究多因素多水平的一种设计方法，他是一种基于正交表的高效率、快速、经济的试验设计方法。

### 4.状态迁移法

状态迁移法是对一个状态在给定的条件内能够产生需要的状态变化，有没有出现不可达的状态和非法的状态，状态迁移法是设计足够的用例达到对系统状态的覆盖、状态、条件组合、状态迁移路径的覆盖。

### 5.流程分析法

流程分析法主要针对测试场景类型属于流程测试场景的测试项下的测试子项进行设计，这是从白盒测试中路径覆盖分析法借鉴过来的一种很重要的方法。

### 6.输入域测试法

输入域测试法是针对输入会有各种各样的输入值的一个测试，主要考虑 极端测试、中间范围测试，特殊值测试 。

### 7.输出域分析法

输出域分析法是对输出域进行等价类和边界值分析，确定是要覆盖的输出域样点，反推得到应该输入的输入值，从而构造出测试用例，他的目的是为了达到输出域的等价类和边界值覆盖。

### 8.判定表分析法

判定表是分析和表达多种输入条件下系统执行不同动作的工具，他可以把复杂的逻辑关系和多种条件组合的情况表达的即具体又明确；

### 9.因果图法

因果图是用于描述系统输入输出之间的因果关系、约束关系。因果图的绘制过程是对被测系统的外部特征的建模过程，根据输入输出间的因果图可以得到判定表，从而规划出测试用例。

### 10.错误猜测法

错误猜测法主要是针对系统对于错误操作时对于操作的处理法的猜测法，从而设计测试用例

### 11.异常分析法

异常分析法是针对系统有可能存在的异常操作，软硬件缺陷引起的故障进行分析，分析发生错误时系统对于错误的处理能力和恢复能力依此设计测试用例。

## 白盒测试：

也称为**结构测试**或**逻辑驱动测试**，是针对被测单元**内部是如何进行工作**的测试。白盒测试法**检查程序内部逻辑结构**，对所有的**逻辑路径**进行测试，是一种**穷举路径**的测试方法，但即使每条路径都测试过了，但仍然有可能存在错误。因为：穷举路径测试无法检查出**程序本身是否违反了设计规范**，即**程序是否是一个错误的程序**；穷举路径测试不可能检查出程序因为**遗漏路径而出错**；穷举路径测试发现不了一些与**数据相关的错误**。

白盒测试需要遵循的原则有：1. 保证一个模块中的**所有独立路径**至少被测试一次；2. 所有**逻辑值均需要测试真（true）和假（false）**两种情况；3. 检查程序的**内部数据结构**，保证其结构的有效性；4. **在上下边界及可操作范围内运行所有循环**。

常用白盒测试方法：

### **1 静态测试**

**不用运行程序**的测试，包括**代码检查**、**静态结构分析**、**代码质量度量**、**文档测试**等等，它可以由人工进行，充分发挥人的逻辑思维优势，也可以借助软件工具（Fxcop）自动进行。

### **2 动态测试**

**需要执行代码**，**通过运行程序找到问题**，包括**功能确认、接口测试、覆盖率分析、性能分析、内存分析**等。

白盒测试中的**逻辑覆盖**包括**语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖**。六种覆盖标准发现错误的能力呈由弱到强的变化：

​		1.语句覆盖每条语句至少执行一次。

​		2.判定覆盖每个判定的每个分支至少执行一次。

​		3.条件覆盖每个判定的每个条件应取到各种可能的值。

​		4.判定/条件覆盖同时满足判定覆盖条件覆盖。

​		5.条件组合覆盖每个判定中各条件的每一种组合至少出现一次。

​		6.路径覆盖使程序中每一条可能的路径至少执行一次。

# Bug的严重性和优先级

Bug的priority（）和severity（）是两个重要属性，通常人员在提交bug的时候，只定义severity，而将priority交给leader定义，通常bug管理中，severity分为四个等级blocker、critical、major、minor/trivial，而priority分为五个等级immediate、urgent、high、normal、low。

### Severity：

1、blocker：即系统无法执行，崩溃，或严重资源不足，应用模块无法启动或异常退出，无法测试，造成系统不稳定。常见的有严重花屏、内存泄漏、用户数据丢失或破坏、系统崩溃/死机/冻结、模块无法启动或异常退出、严重的数值计算错误、功能设计与需求严重不符、其它导致无法测试的错误， 如服务器500错误。

2、critical：即映像系统功能或操作，主要功能存在严重缺陷，但不会映像到系统稳定性。常见的有：功能未实现，功能错误、系统刷新错误、数据通讯错误、轻微的数值计算错误、影响功能及界面的错误字或拼写错误。

3、major：即界面、性能缺陷、兼容性，常见的有：操作界面错误，边界条件错误，提示信息错误，长时间操作无进度提示，系统未优化，兼容性问题。

4、minor/trivial：即易用性及建议性问题。

### Priority

1、immediate：即马上解决，

2、urgent：急需解决

3、high：高度重视，有时间要马上解决

4、low：在系统发布前解决，或确认可以不用解决。



# 测试的类型

### 1、单元测试

完成最小的软件设计单元（模块）的验证工作，目标是确保模块被正确的编码，使用**过程设计描述作为指南**，对重要的**控制路径进**行测试以发现模块内的错误，通常情况下是**白盒**的，对**代码风格和规则、程序设计和结构、业务逻辑**等进行**静态测试**，及早的发现和解决不易显现的错误。

### 2、集成测试

通过测试发现与**模块接口有关的问题**。目标是把**通过了单元测试的模块**拿来，构造一个在设计中所描述的程序结构，应当**避免一次性的集成**（除非软件规模很小），而采用**增量集成**。

**自顶向下集成**：模块集成的顺序是首**先集成主模块**，然后按照**控制层次结构向下进行集成**，隶属于主模块的模块按照**深度优先**或**广度优先**的方式集成到整个结构中去。

**自底向上集成**：从**原子模块**开始来进行构造和测试，因为模块是自底向上集成的，进行时要求**所有隶属于某个给顶层次的模块**总是存在的，也不再有使用稳定测试桩的必要。

### 3、系统测试(最重要)

是基于**系统整体需求说明书**的**黑盒**类测试，应覆盖系统所有联合的部件。系统测试是针对**整个产品系统进行的测试**，目的是验证系统是否满足了需求规格的定义，找出与需求规格不相符合或与之矛盾的地方。系统测试的对象不仅仅包括**需要测试的产品系统的软件**，还要**包含软件所<u>依赖</u>的硬件、外设甚至包括某些数据、某些支持软件及其接口**等。因此，必须将系统中的软件与各种依赖的资源结合起来，在系统实际运行环境下来进行测试。

### 4、回归测试

回归测试是指在**发生修改之后重新测试先前的测试用例**以保证修改的正确性。理论上，软件产生**新版本，都需要进行回归测试**，验证**以前发现和修复的错误是否在新软件版本上再次出现**。根据修复好了的缺陷再重新进行测试。一般指对某已知修正的缺陷再次围绕它原来出现时的步骤重新测试。

### 5、验收测试

验收测试是指系统开发生命周期方法论的一个阶段，这时相关的用户或独立测试人员根据**测试计划和结果对系统进行测试和接收**。它让系统用户决定是否接收系统。它是一项确定产品是否能够满足合同或用户所规定需求的测试。验收测试包括Alpha测试和Beta测试。

#### Alpha测试

是由**用户在开发者的场所**来进行的，在一个受控的环境中进行。

#### Beta测试

由软件的**最终用户**在一个或多个用户场所来进行的，**开发者通常不在现场**，用户记录测试中遇到的问题并报告给开发者，开发者对系统进行最后的修改，并开始准备发布最终的软件。

### 请回答集成测试和系统测试的区别，以及它们的应用场景主要是什么？

区别：

1、**<u>计划</u>和用例编制的先后顺序**：从V模型来讲，在需求阶段就要制定系统测试计划和用例，HLD的时候做集成测试计划和用例，有些公司的具体实践不一样，但是顺序肯定是**先做系统测试计划用例，再做集成**。

2、用例的粒度：**系统测试用例**相对很**接近用户接受测试用例**，**集成测试用例**比系统测试用例**更详细**，而且对于**接口部分要重点写**，毕竟要集成各个模块或者子系统。

3、**<u>执行</u>测试的顺序**：**先执行集成测试，待集成测试出的问题修复之后，再做系统测试**。

应用场景：

集成测试：完成单元测试后，各模块联调测试；集中在各模块的接口是否一致、各模块间的数据流和控制流是否按照设计实现其功能、以及结果的正确性验证等等；可以是整个产品的集成测试，也可以是大模块的集成测试；集成测试主要是针对程序内部结构进行测试，特别是对程序之间的接口进行测试。集成测试对测试人员的编写脚本能力要求比较高。测试方法一般选用黑盒测试和白盒测试相结合。

系统测试：针对整个产品的全面测试，既包含各模块的验证性测试（验证前两个阶段测试的正确性）和功能性（产品提交个用户的功能）测试，又包括对整个产品的健壮性、安全性、可维护性及各种性能参数的测试。系统测试测试软件《需求规格说明书》中提到的功能是否有遗漏，是否正确的实现。做系统测试要严格按照《需求规格说明书》，以它为标准。测试方法一般都使用黑盒测试法。

# app性能测试的指标

### 1、内存：

内存消耗测试节点的设计目标是为了让应用不占用过多的系统资源，且及时释放内存，保障整个系统的稳定性。当然关于内存测试，在这里我们需要引入几个概念：空闲状态、中等规格、满规格。

空闲状态指打开应用后，点击home键让应用后台运行，此时应用处于的状态叫做空闲；中等规格和满规格指的是对应用的操作时间的间隔长短不一，中等规格时间较长，满规格时间较短。

内存测试中存在很多测试子项，清单如下：

●空闲状态下的应用内存消耗；

●中等规格状态下的应用内存消耗；

●满规格状态下的应用内存消耗；

●应用内存峰值；

●应用内存泄露；

●应用是否常驻内存；

●压力测试后的内存使用。

### 2、CPU：

使用Android提供的view plaincopy在CODE上查看代码片派生到我的代码片

adbshell dumpsys CPUinfo |grep packagename >/address/CPU.txt来获取；

使用top命令view plaincopy在CODE上查看代码片派生到我的代码片

adbshell top |grep packagename>/address/CPU.txt来获取。

### 3、流量：

网络流量测试是针对大部分应用而言的，可能还有部分应用会关注网速、弱网之类的测试。

流量测试包括以下测试项：

应用首次启动流量提示；

应用后台连续运行2小时的流量值；

应用高负荷运行的流量峰值。

### 4、电量：

●测试手机安装目标APK前后待机功耗无明显差异；

●常见使用场景中能够正常进入待机，待机电流在正常范围内；

●长时间连续使用应用无异常耗电现象。

### 5、启动速度：

第一类：首次启动--应用首次启动所花费的时间；

第二类：非首次启动--应用非首次启动所花费的时间；

第三类：应用界面切换--应用界面内切换所花费的时间。

### 6、滑动速度、界面切换速度

### 7、与服务器交互的网络速度

# 请你说一说bug的周期，以及描述一下不同类别的bug

### 参考回答：

### 1、New:（新的）

当某个“bug”被第一次发现的时候，测试人员需要与项目负责人沟通以确认发现的的确是一个bug，如果被确认是一个bug，就将其记录下来，并将bug的状态设为New

### 2、Assigned（已指派的）

当一个bug被指认为New之后，将其反馈给开发人员，开发人员将确认这是否是一个bug，如果是，开发组的负责人就将这个bug指定给某位开发人员处理，并将bug的状态设定为“Assigned”

### 3、Open（打开的）

一旦开发人员开始处理bug的时候，他（她）就将这个bug的状态设置为“Open”，这表示开发人员正在处理这个“bug”

### 4、Fixed（已修复的）

当开发人员进行处理（并认为已经解决）之后，他就可以将这个bug的状态设置为“Fixed”并将其提交给开发组的负责人，然后开发组的负责人将这个bug返还给测试组

### 5、Pending Reset（待在测试的）

当bug被返还到测试组后，我们将bug的状态设置为Pending Reset”

### 6、Reset(再测试)

测试组的负责人将bug指定给某位测试人员进行再测试，并将bug的状态设置为“Reset”

### 7、Closed（已关闭的）

如果测试人员经过再次测试之后确认bug 已经被解决之后，就将bug的状态设置为“Closed”

### 8、Reopen（再次打开的）

如果经过再次测试发现bug（指bug本身而不是包括因修复而引发的新bug）仍然存在的话，测试人员将bug再次传递给开发组，并将bug的状态设置为“Reopen”

### 9、Pending Reject（拒绝中）

如果测试人员传递到开发组的bug被开发人员认为是正常行为而不是bug时，这种情况下开发人员可以拒绝，并将bug的状态设置为“Pending Reject”

### 10、Rejected(被拒绝的)

测试组的负责人接到上述bug的时候，如果他（她）发现这是产品说明书中定义的正常行为或者经过与开发人员的讨论之后认为这并不能算作bug的时候，开发组负责人就将这个bug的状态设置为“Rejected”

### 11、Postponed（延期）

有些时候，对于一些特殊的bug的测试需要搁置一段时间，事实上有很多原因可能导致这种情况的发生，比如无效的测试数据，一些特殊的无效的功能等等，在这种情况下，bug的状态就被设置为“Postponed“

不同类别的bug：

Bug类型

•  代码错误

•  界面优化

•  设计缺陷

•  配置相关

•  安装部署

•  安全相关

•  性能问题

•  标准规范

•  测试脚本

•  其他

# 请你说一说PC网络故障，以及如何排除障碍

### (1)首先是排除接触故障，

即确保你的网线是可以正常使用的。然后禁用网卡后再启用，排除偶然故障。打开网络和共享中心窗口，单击窗口左上侧“更改适配器设置”右击其中的“本地连接“或”无线网络连接”，单击快捷菜单中的“禁用”命令，即可禁用所选网络。接下来重启网络，只需右击后单击启用即可。

### (2)使用ipconfig查看计算机的上网参数

​		1、单击“开始|所有程序|附件|命令提示符“，打开命令提示符窗口

​		2、输入ipconfig，按Enter确认，可以看到机器的配置信息，输入ipconfig/all,可以看到IP地址和网卡物理地址		等相关网络详细信息。

### (3)使用ping命令测试网络的连通性，定位故障范围

在命令提示符窗口中输入”ping 127.0.0.1“，数据显示本机分别发送和接受了4个数据包，丢包率为零，可以判断本机网络协议工作正常，如显示”请求超时“，则表明本机网卡的安装或TCP/IP协议有问题，接下来就应该检查网卡和TCP/IP协议，卸载后重装即可。

### (4)ping本机IP

在确认127.0.0.1地址能被ping通的情况下，继续使用ping命令测试本机的IP地址能否被ping通，如不能，说明本机的网卡驱动程序不正确，或者网卡与网线之间连接有故障，也有可能是本地的路由表面收到了破坏，此时应检查本机网卡的状态是否为已连接，网络参数是否设置正确，如果正确可是不能ping通，就应该重新安装网卡驱动程序。丢失率为零，可以判断网卡安装配置没有问题，工作正常。

### (5)ping网关

网关地址能被ping通的话，表明本机网络连接以及正常，如果命令不成功，可能是网关设备自身存在问题，也可能是本机上网参数设置有误，检查网络参数。

# web测试和app测试的不同点

### 系统架构方面：

web项目，一般都是b/s架构，基于浏览器的

app项目，则是c/s的，必须要有客户端，用户需要安装客户端。

web测试只要更新了服务器端，客户端就会同步会更新。

App项目则需要客户端和服务器都更新。

### 性能方面:

web页面主要会关注响应时间

app则还需要额外关心流量、电量、CPU、GPU、Memory这些。

它们服务端的性能没区别，都是一台服务器。

### 兼容方面：

web是基于浏览器的，所以更倾向于浏览器和电脑硬件，电脑系统的方向的兼容

app测试则要看分辨率，屏幕尺寸，还要看设备系统。

web测试是基于浏览器的所以不必考虑安装卸载。

而app是客户端的，则必须测试安装、更新、卸载。除了常规的安装、更新、卸载还要考虑到异常场景。包括安装时的中断、弱网、安装后删除安装文件 。

此外APP还有一些专项测试：如网络、适配性。