# 操作系统

------

## 操作系统基础

### 定义

<img src="https://camo.githubusercontent.com/0db97dd933efd0f558100d9ae4b0d56e0c05f4cb52e429f77cf24c1e5da6c70e/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f323032302d382f4b65726e656c5f4c61796f75742e706e67" alt="Kernel_Layout" style="width:40%;" />

1. **操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。** 运行在电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。
2. 操作系统的存在**屏蔽了硬件层的复杂性**。
3. **操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理**。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。

### 系统调用

根据**进程访问资源**的特点，我们可以把进程在系统上的运行分为两个级别：

1. **用户态 user mode**: 用户态运行的**进程**可以直接**读取用户程序的数据**。
2. **系统态(内核态) kernel mode**: 系统态运行的**进程或程序**几乎可以访问计算机的**任何资源**，不受限制。

**什么是系统调用呢？**

我们的**程序**基本都是**运行在用户态**，我们调用**操作系统提供的系统态级别的子功能**就需要**系统调用**了。凡是与**系统态级别的资源有关的操作**（如**文件管理、进程控制、内存管理**等)，都必须**通过系统调用方式向操作系统提出服务请求**，并由操作系统代为完成。

这些系统调用按功能大致可分为如下几类：

- **设备管理**。完成设备的请求或释放，以及设备启动等功能。
- **文件管理**。完成文件的读、写、创建及删除等功能。
- **进程控制**。完成**进程的创建、撤销、阻塞及唤醒**等功能。
- **进程间通信**。完成进程之间的消息传递或信号传递等功能。
- **内存管理**。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

## 进程和线程

### 进程与线程的区别

一个**进程**在其执行的过程中**可以产生多个线程**。

线程和进程最大的不同在于基本上**各进程是独立的**，而**各线程则不一定是独立**的，因为**同一进程中的线程极有可能会相互影响**。

**线程**执行**开销小**，但**不利于资源的管理和保护**；而进程正相反。

<img src="imgs/image-20210726190454877.png" alt="image-20210726190454877" style="width:80%;" />

> 如果你对 Java 内存区域 (运行时数据区) 这部分知识不太了解的话可以阅读一下这篇文章：[《可能是把 Java 内存区域讲的最清楚的一篇文章》](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java内存区域)

以JVM为例**一个进程有多个线程**，多个线程**共享进程**的**堆**和**方法区 (JDK1.8 之后的元空间)**资源，但是每个线程有自己的**程序计数器**、**虚拟机栈** 和 **本地方法栈**。

### 进程有哪几种状态?

我们一般把进程大致分为 5 种状态，这一点和[线程](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md#6-说说线程的生命周期和状态)很像！

- **创建状态(new)** ：进程**正在被创建**，**尚未到就绪状态**。
- **就绪状态(ready)** ：进程已处于**准备运行状态**，即进程**获得了除了处理器之外**的**一切所需资源**，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)** ：进程**正在处理器(内核)上运行**(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(waiting)** ：又称为等待状态，**进程正在等待某一事件而暂停运行**，如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

> 订正：下图中 running 状态被 interrupt 向 ready 状态转换的箭头方向反了。

[![process-state](https://camo.githubusercontent.com/fa3044833393a5a207f155bc6e72f8f750f2d370ca7488ce114e6e5c7f666bf8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f64333832303235393330313262343537646562626364373439393463363239322e706e67)](https://camo.githubusercontent.com/fa3044833393a5a207f155bc6e72f8f750f2d370ca7488ce114e6e5c7f666bf8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f64333832303235393330313262343537646562626364373439393463363239322e706e67)

### 线程间同步的方式

当两个或多个**共享关键资源的线程的并发**执行，同步线程以**避免关键的资源使用冲突**。操作系统一般有下面三种线程同步的方式：

1. **互斥量(Mutex)**：采用**互斥对象机制**，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 **synchronized** 关键词和各种 **Lock** 都是这种机制。
2. **信号量(Semphares)** ：它**允许同一时刻多个线程访问同一资源**，但是需要控制同一时刻访问此资源的**最大线程数量**
3. **事件(Event)** :**Wait/Notify**：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

### 进程间通信的方式

参考：https://www.jianshu.com/p/c1015f5ffa74

1. **管道/匿名管道(Pipes)** ：用于具有亲缘关系的**父子进程间**或者**兄弟进程间**的通信，存在于**内存中**的文件。

2. **有名管道(Names Pipes)** : 匿名管道由于**没有名字**，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(FIFO)**。有名管道存在于**磁盘介质或者文件系统**中，可以实现本机任意两个进程通信。

3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于**通知接收进程某个事件已经发生**；

4. **消息队列(Message Queuing)** ：

    消息队列是**消息的链表**(先进先出FIFO), 消息队列可以实现消息的**随机查询**,消息不一定要以先进先出的次序读取, 也可以按**消息的类型读取**, 比 FIFO 更有优势。

    存放在**内核中**并由消息队列标识符标识, 只有在**内核重启**(即**操作系统重启**)或者**显示地删除一个消息队列时**，该消息队列才会被真正的删除。

    **消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。**

5. **信号量(Semaphores)** ：信号量是一个**计数器**，用于**多进程对共享数据的访问**，信号量的意图在于**进程间同步**。这种通信方式主要用于解决与同步并发相关的问题并避免竞争条件。

6. **共享内存(Shared memory)** ：使得**多个进程可以访问的同一块内存空间**，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要**依靠某种同步操作**，如**互斥锁**和**信号量**等。可以说这是**最有用的进程间通信方式**。

7. **套接字(Sockets)** : 此方法主要用于在**客户端和服务器之间**通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是**不同主机之间的进程进行双向通信的端点**，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

### 进程的调度算法

为了确定**进程的执行顺序**以实现**最大 CPU 利用率**，可以采用一些算法：

- **先到先服务(FCFS)调度算法** : 从就绪队列中选择一个**最先进入该队列的进程**为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。

- **短作业优先(SJF)的调度算法** : 从就绪队列中选出一个**估计运行时间最短的进程**为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。

    缺点：仅照顾了**短进程**而**忽略了优先级**。

- **时间片轮转调度算法** : **每个进程被分配一个时间段**，称作它的时间片，即**该进程允许运行的时间**。

- **优先级调度** ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

    缺点：仅照顾了优先级而短进程会被滞后完成

- **多级反馈队列调度算法** ：多级反馈队列调度算法既能使**高优先级**的**进程得到响应**又能使**短作业（进程）迅速完成**。因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。

    [![多级反馈队列调度算法图示](https://bkimg.cdn.bcebos.com/pic/8435e5dde71190ef5858f621c51b9d16fcfa60a8?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto)](https://baike.baidu.com/pic/多级反馈队列调度算法/449587/0/8435e5dde71190ef5858f621c51b9d16fcfa60a8?fr=lemma&ct=single)

    **1、**设有N个队列（Q1,Q2....QN），其中各个队列对于[处理机](https://baike.baidu.com/item/处理机)的[优先级](https://baike.baidu.com/item/优先级/5643121)是不一样的，也就是说位于各个队列中的作业(进程)的优先级也是不一样的。一般来说，优先级Priority(Q1) > Priority(Q2) > ... > Priority(QN)。怎么讲，位于Q1中的任何一个作业(进程)都要比Q2中的任何一个作业(进程)相对于CPU的优先级要高（也就是说，Q1中的作业一定要比Q2中的作业先被[处理机调度](https://baike.baidu.com/item/处理机调度)），依次类推其它的队列。

    **2、**对于优先级最低的队列来说，里面是遵循[时间片轮转](https://baike.baidu.com/item/时间片轮转)法。也就是说，位于队列QN中有M个作业，它们的运行时间是通过QN这个队列所设定的[时间片](https://baike.baidu.com/item/时间片/6525414)来确定的；对于其他队列，遵循的是先来先服务算法，每一进程分配一定的时间片，若时间片运行完时进程未结束，则进入下一优先级队列的末尾。

    **3、**各个队列的时间片是一样的吗？不一样，这就是该算法设计的精妙之处。**优先级越高的队列中它的时间片就越短**。同时，为了便于那些超大作业的完成，最后一个队列QN(优先级最低的队列)的时间片一般很大(不需要考虑这个问题)。

### 什么是死锁

如果系统中以下**四个条件同时成立**，那么就能引起死锁：

- **互斥**：资源必须处于**非共享模式**，即**一次只有一个进程可以使用**。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。
- **占有并等待**：一个进程至少应该占有一个资源，并等待另一资源，而**该资源被其他进程所占有。**
- **非抢占**：资源不能被抢占。**只能在持有资源的进程完成任务后，该资源才会被释放。**
- **循环等待**：有一组等待进程 `{P0, P1,..., Pn}`， `P0` 等待的资源被 `P1` 占有，`P1` 等待的资源被 `P2` 占有，......，`Pn-1` 等待的资源被 `Pn` 占有，`Pn` 等待的资源被 `P0` 占有。

