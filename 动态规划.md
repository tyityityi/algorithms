# Dynamic Programming 动态规划

------

## 框架

求解动态规划的核心问题是**穷举**。动态规划的穷举有点特别，因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要「**备忘录**」或者「DP table」来**优化穷举过程**，避免不必要的计算。

而且，动态规划问题一定会**具备「最优子结构」**，才能通过子问题的最值得到原问题的最值。

另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出**正确的「状态转移方程」**，才能正确地穷举。

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。

```java
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

### [LC509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。

示例 1：

输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
示例 2：

输入：3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
示例 3：

输入：4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3

函数签名:

```java
public int fib(int n)
```

#### Solution1: 暴力递归

```java
public int fib(int n){
  	if(n==0)
      	return 0;
  	if(n==1)
      	return 1;
		return fib(n-1)+fib(n-2);
}
```

##### 问题：

**递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。**

首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。

然后计算解决一个子问题的时间，在本算法中，没有循环，只有 `f(n - 1) + f(n - 2)` 一个加法操作，时间为 O(1)。

所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。

<img src="imgs/image-20210723122833847.png" alt="image-20210723122833847" style="width:67%;" />

f(18)、f(17)...会被重复计算，这就是动态规划问题的第一个性质：**重叠子问题**。

#### Solution2: 自顶向下 - 带备忘录的递归解法 - 用备忘录解决重叠子问题

可以造一个「备忘录」，**每次遇到一个子问题先去「备忘录」里查一查**：

​		如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了；

​		如果发现之前没解决过这个问题，就去算，算完记到备忘录里。

一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。

```java
		public int fib(int n) {
        int[] memo = new int[n+1];
        return fibHelper(n, memo);
    }
    public int fibHelper(int n, int[] memo){
        if(n==0)
            return 0;
        if(n==1)
            return 1;
    
        if(memo[n]!=0)//结果已经计算过并存在备忘录中
            return memo[n];
        //不存在于备忘录中，算出结果，添加进去
        memo[n] = fibHelper(n-1, memo)+fibHelper(n-2, memo);
        return memo[n];
    } 
```

<img src="imgs/image-20210723124853133.png" alt="image-20210723124853133" style="width:67%;" />

子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 `f(1)`, `f(2)`, `f(3)` ... `f(20)`，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。

解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。

所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。

这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。

啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 `f(20)`，向下逐渐分解规模，直到 `f(1)` 和 `f(2)` 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。

<img src="imgs/image-20210723125421008.png" alt="image-20210723125421008" style="width:67%;" />

啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 `f(1)` 和 `f(2)` 开始往上推，直到推到我们想要的答案 `f(20)`，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

<img src="imgs/image-20210723125439868.png" alt="image-20210723125439868" style="width:67%;" />

#### Solution3: 自底向上 - 带备忘录的迭代解法 - 用备忘录解决重叠子问题

这里，引出「**状态转移方程**」这个名词，实际上就是描述问题结构的数学形式：

​		**f(n) = 0 if n==0;** - base case 1

​		**f(n) = 1 if n==1;** - base case2

​		**f(n) = f(n-1) + f(n-2) if n>=2;** - 通用case

你把 `f(n)` 想做一个状态 `n`，这个状态 `n` 是由状态 `n - 1` 和状态 `n - 2` 相加转移而来，这就叫状态转移。

```java
		public int fib(int n) {
        if(n==0)
            return 0;

        int[] dp = new int[n+1];
        //base case
        dp[0] = 0;
        dp[1] = 1;
        //状态转移方程
        for(int i=2; i<=n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
```

**动态规划问题最困难的就是写出这个暴力解，即状态转移方程**。

本算法的时间复杂度是 O(n)。

这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和**之前的两个状态**有关，其实并**不需要那么长的一个 DP table 来存储所有的状态**，只要用prev 和 curr来存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：

```java
    public int fib(int n) {
        if (n < 1) return 0;
        if (n == 2 || n == 1) 
            return 1;
        int prev = 1, curr = 1;
        for (int i = 3; i <= n; i++) {
            int sum = prev + curr;
            prev = curr;
            curr = sum;
        }
        return curr;
    }
```

这个技巧就是所谓的「**状态压缩**」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 `n` 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，**一般来说是把一个二维的 DP table 压缩成一维**，即把空间复杂度从 O(n^2) 压缩到 O(n)。

### [LC322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount (>=0)，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

示例 1：

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
示例 2：

输入：coins = [2], amount = 3
输出：-1
示例 3：

输入：coins = [1], amount = 0
输出：0
示例 4：

输入：coins = [1], amount = 1
输出：1
示例 5：

输入：coins = [1], amount = 2
输出：2

函数签名：

```java
public int coinChange(int[] coins, int amount);
```

1、**确定 base case**，这个很简单，显然目标金额 `amount` 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。

2、**确定「状态」，也就是原问题和子问题中会变化的变量**。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 `amount`。

3、**确定「选择」，也就是导致「状态」产生变化的行为**。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。

4、**明确** **`dp`** **数组的定义**。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 `dp` 函数：

`dp(n)` 的定义：**输入一个目标金额 `n`，返回凑出目标金额 `n` 的最少硬币数量。**

<img src="imgs/image-20210723141046760.png" alt="image-20210723141046760" style="width:67%;" />

#### Solution1: 带备忘录的递归

```java
		public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        dpCoinChange(coins, amount, dp);
        return dp[amount];
        }
    public int dpCoinChange(int[] coins, int amount, int[] dp){
        //base case
        if(amount==0)
            return 0;
        if(amount<0)
            return -1;
        //查备忘录. 
        if(dp[amount]!=0)
            return dp[amount];
        //计算当前amount所需coin个数的最小值    
        int min = Integer.MAX_VALUE;
        for(int i=0; i<coins.length; i++){
            int subproblem = dpCoinChange(coins, amount-coins[i], dp);
            if(subproblem>=0)//subproblem有解
                if(1+subproblem<min)//+1是因为这次计算会消耗一枚硬币
                    min = 1+subproblem;
        }
        if(min!=Integer.MAX_VALUE)//min有被更新
            dp[amount] = min;
        else//min未被更新，无解
            dp[amount] = -1;
        return dp[amount];
    }
```

<img src="imgs/image-20210723155049601.png" alt="image-20210723155049601" style="width:67%;" />

时间复杂度：O(Sn)，其中 S 是金额，n 是面额数。我们一共需要计算 S 个状态的答案，且每个状态 dp(S) 由于上面的记忆化的措施只计算了一次，而计算一个状态的答案需要枚举 n 个面额值，所以一共需要 O(Sn)的时间复杂度。
空间复杂度：O(S)，我们需要额外开一个长为 S 的数组来存储计算出来的答案 dp(S) 。

#### Solution2: dp 数组的迭代解法

```java
		public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        //base case
        dp[0] = 0;
        for(int i=1; i<=amount; i++){
            //初始化一个最大值（这里不能是Integer.MAX_VALUE是因为Integer.MAX_VALUE+1 == Integer.MIN_VALUE 
            dp[i] = amount+1;
        }
        // 外层 for 循环在遍历所有状态的所有取值
        for(int i=1; i<=amount; i++){
            // 内层 for 循环在求所有选择的最小值
            for(int c=0; c<coins.length; c++){
                // 子问题无解，跳过
                if(i-coins[c]<0)
                    continue;
                dp[i] = Math.min(dp[i], 1+dp[i-coins[c]]);
            }
        }
        if(dp[amount]<amount+1)
            return dp[amount];
        else
            return -1;
    }
```

<img src="imgs/image-20210723155005397.png" alt="image-20210723155005397" style="width:67%;" />

## [LC72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

示例 1：输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

示例 2：输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')

函数签名：

```java
public int minDistance(String s1, String s2);
```

### 思路：

**解决两个字符串的动态规划问题，一般都是用两个指针** **`i,j`** **分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模**。

![img](https://gblobscdn.gitbook.com/assets%2F-Me2HTYUybY4ojrYvI-8%2Fsync%2F1912ddf88b038ff8d0097dbb3f584989f4f2019d.gif?alt=media)

![img](https://gblobscdn.gitbook.com/assets%2F-Me2HTYUybY4ojrYvI-8%2Fsync%2F3f2f0b50ad4671a02ce0b1ce41e7a9dbb2d2df75.jpg?alt=media)

**base case** 是 `i` 走完 `s1` 或 `j` 走完 `s2`，可以直接返回另一个字符串剩下的长度。

对于**每对儿字符 `s1[i]` 和 `s2[j]`**，可以有四种操作：

```java
if s1[i] == s2[j]:
    啥都别做（skip）
    i, j 同时向前移动
else:
    三选一：
      插入（insert）
      删除（delete）
      替换（replace）
```

这个「三选一」到底该怎么选择呢？很简单，全试一遍，哪个操作最后得到的编辑距离最小，就选谁

![img](https://gblobscdn.gitbook.com/assets%2F-MfGzadyeeE4YNE75vTY%2Fsync%2F8982acb93223abd6679adc3afbde71b0dd745614.gif?alt=media)

![img](https://gblobscdn.gitbook.com/assets%2F-MfGzadyeeE4YNE75vTY%2Fsync%2F36559b37dd118d77713ebc57ecfdcf11a2de599a.gif?alt=media)

![img](https://gblobscdn.gitbook.com/assets%2F-MfGzadyeeE4YNE75vTY%2Fsync%2Fb2153166d681c0557bb40d2276f9b5707ba9b252.gif?alt=media)

### Solution1: 暴力递归

```java
		public int minDistance(String s1, String s2) {
        //以字符串最后一位的索引string.length()-1位起点
        return recurMinDistance(s1, s1.length()-1, s2, s2.length()-1);
    }
    //返回s1[0...i]和s2[0...j]的最小编辑距离
    public int recurMinDistance(String s1, int i, String s2, int j){
      	//base case: 其中一个str遍历结束时，需要的时间为插入另一个str剩下的char所需时间
        if(i<0) 
            return j+1;
        if(j<0)
            return i+1;
        
        if(s1.charAt(i)==s2.charAt(j)){
            //本来就相等，不需要任何操作
            //s1[0..i] 和 s2[0..j] 的最小编辑距离等于s1[0..i-1] 和 s2[0..j-1] 的最小编辑距离
            //也就是说 recurMinDistance(i, j) 等于 recurMinDistance(i-1, j-1)
            return recurMinDistance(s1, i-1, s2, j-1);
        }
        else {
            //插入：s[i]插入一个与s2[j]相同字符，那么s1[i+1]与s2[j]匹配成功；所以s1指针i不变，s2指针j前移一位继续跟i对比
            int min = recurMinDistance(s1, i, s2, j-1) + 1;//+1为插入的消耗
            //删除：s1[i]的指针删除，用下一位s1[i-1]继续与s2[j]匹配，所以s2指针j不变，s1指针i前移一位继续跟s2指针j对比
            min = Math.min(recurMinDistance(s1, i-1, s2, j)+1, min);//+1为删除的消耗
            //替换: 将s1[i]前面的某个字符替换到当前字符，那么这一位s1[i]=s2[j]通过了匹配; s1、s2指针i、j都前移一位继续对比
            min = Math.min(recurMinDistance(s1, i-1, s2, j-1)+1, min);//+1为替换的消耗
            return min;
        }
    }
```

### Solution2: 带备忘录的递归

memo数组是一个二维数组，长这样：

<img src="imgs/image-20210724230939536.png" alt="image-20210724230939536" style="width:50%;" />

```java
		
		public int minDistance(String s1, String s2) {
        //初始化备忘录，memo[i][j]记录s1[0...i]和s2[0...j]的最小编辑距离
        int[][] memo = new int[s1.length()][s2.length()];
        //以字符串最后一位的索引string.length()-1为起点
        return recurMinDistance(s1, s1.length()-1, s2, s2.length()-1, memo);
    }
    //返回s1[0...i]和s2[0...j]的最小编辑距离
    public int recurMinDistance(String s1, int i, String s2, int j, int[][] memo){
        if(i<0) 
            return j+1;
        if(j<0)
            return i+1;
        //查备忘录
        if(memo[i][j]!=0) 
            return memo[i][j];
        if(s1.charAt(i)==s2.charAt(j)){
            //更新备忘录
            memo[i][j] = recurMinDistance(s1, i-1, s2, j-1, memo);
            return memo[i][j];
        }
        else {
            int min = recurMinDistance(s1, i, s2, j-1, memo) + 1;
            min = Math.min(recurMinDistance(s1, i-1, s2, j, memo)+1, min);
            min = Math.min(recurMinDistance(s1, i-1, s2, j-1, memo)+1, min);
            //更新备忘录
            memo[i][j] = min;
            return memo[i][j];
        }
    }
```

### Solution3: dp数组的迭代解法 

当i、j为0时，`memo[0][0] = min(dp(0,-1)+1,dp(-1,0)+1, dp(-1,-1)+1)`，<u>**递归的解法**</u>可以用base case直接返回值来处理`memo[0][-1]、memo[-1][0]、memo[-1][-1]`的情况，但**迭代**的解法中**数组的索引无法取到-1**，所以要将**整个数组向右平移一位**(idx = idx+1)。

<img src="imgs/image-20210724230939536.png" alt="image-20210724230939536" style="width:50%;" />

`memo[..][0]` 和 `memo[0][..]` 对应 base case。

```java
		public int minDistance(String s1, String s2) {
        //dp[i][j]存储的是s1[0...i-1]和s2[0...j-1]的最小编辑距离，
        int[][] dp = new int[s1.length()+1][s2.length()+1];
    
        //初始化base case
        for(int i=0; i<=s1.length(); i++){//!!!结束条件是i=s1.length()
            dp[i][0] = i;
        }
        for(int j=0; j<=s2.length(); j++){
            dp[0][j] = j;
        }

        //结束条件是i=s1.length()是因为数组长度为s1.length()+1, s1.length()就是数组最后一个元素的的索引
        for(int i=1; i<=s1.length(); i++){
            for(int j=1; j<=s2.length(); j++){
                //i-1才是char在str里的实际位置
                if(s1.charAt(i-1)==s2.charAt(j-1))
                    dp[i][j] = dp[i-1][j-1];
                else{
                    int min = dp[i][j-1]+1;
                    min = Math.min(dp[i-1][j]+1, min);
                    min = Math.min(dp[i-1][j-1]+1, min);
                    //更新备忘录
                    dp[i][j] = min;
                }
            }
        }
        //s1.length()就是数组最后一个元素的的索引
        return dp[s1.length()][s2.length()];
    }
```

### 总结归纳：两个字符串的动态规划问题状态转移关系

处理两个字符串的动态规划问题，都是按本文的思路处理，建立 DP table。为什么呢，因为易于找出状态转移的关系，比如编辑距离的 DP table：

<img src="imgs/image-20210724231819888.png" alt="image-20210724231819888" style="width:80%;" />

既然每个 `dp[i][j]` 只和它附近的三个状态有关，那么遍历方式是**从左上到右下**来遍历，所以是从i++而不是i--。