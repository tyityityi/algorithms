# 智力题

## 1000瓶毒药里面只有1瓶是有毒的，问需要多少只老鼠才能在24小时内试出那瓶有毒。

### 方法一: 二进制数表示法

 https://blog.csdn.net/weixin_45932565/article/details/104579331

### 方法二: 二分法

第一次： 将1-500瓶兑在一起喝。

如果老鼠死了，则拿另一只老鼠去品尝501-725瓶兑的药水。否则去喝2-250瓶兑的水。

采用如此二分法，因为2^10>1000  2^9<1000,所以10次就可以找出。

现在回到原题，老鼠会在24小时后死亡，这样的化就不能跟去前一次的结果作出决策。但是可以覆盖二分的所有支路，在24小时后，一次性作出判断。

相当于将串行的二分法，改为并行的二分法。

具体如下：

第一只： 喝 1-500

第二只 1-250   500-725

第三只  1-125  250-375   500-625  725-850

....

到最后中毒的可以通过交叉中毒分析出是那瓶。也是一只老鼠喝多瓶药水与其他老鼠部分相交而且与每只相交的部分还不一样。当老鼠达到一定数量，就能过滤出到底那瓶有毒了。


## 烧一根不均匀的绳子，从头烧到尾总共需要1个小时，问如何用烧绳子的方法来确定15分钟?

烧两根绳子，

第一根两头一起点，第二根点一头

第一根烧完后点第二根另一端，从此时起计时，至第二根烧完，即15min

## 晚上有四个人过桥，一次只能过两个人，但是只有一只手电筒，四个人过桥时间分别是1，2，5，8，求最短过桥时间

关键是5和8要一起过, 如果1 5, 1 8的过需要多承担一次5的代价.

所以: 首先1和2过桥,1带手电筒回来；然后5和8过桥,由2带手电筒回来；最后1再和2一起过桥.所以最少用时间是2+1+8+2+2=15（分钟）

## 3升的杯子一个，5升的杯子一个，杯子不规则形状 问怎么得到4升的水 水无限多

1、将3升的装满倒入5升的；

2、再一次将3升的转满，倒入5升的，把5升装满；

3、3升杯里剩下的就是1升水；

4、倒掉5升的，把1升水倒入5升杯；

5、第三次加满3升杯，倒入5升杯，得到4升水。

## 两个容积分别为5升和6升的桶，最后如何只装3升？

第一步：先取来6升水，倒进5升桶的水桶里，即得到6升桶里余下的1升水；

第二步：把5L桶清掉，把取到的1升水放进5升的水桶里保留不动，然后再取6升水，倒进5升的水桶里，6升的桶得到的是2升水，把5L桶清掉，存放这2升水；

第三步：5升水桶有2升水．再取6升水，倒进5升水桶里，原有2L升+3升=5升，这时6升-3升=3升，6升里余下的就是3升水了。

## 圆桌，两个人，轮流放硬币，不能重叠，半径为1，某一方不能放下去，则为输。问先手赢 后手赢。

先手赢。

圆桌**对称**，但是**除了圆心**。

会围棋的人一般都知道，只要先手把硬币放在圆桌正中心，随后第二个人无论把硬币放在哪，第一个人都把硬币放在对称的位置，即可，是先放的赢.

## 5只猫5分钟捉5只老鼠 那么在100分钟内捉100只老鼠需要多少只猫？

要把分钟单独看, 5只🐱5分钟捉5只🐭, 即1只🐱5分钟抓1只🐭, 1只🐱100分钟抓20只🐭, 所以抓100只🐭需要5只🐱 

## 100层楼，两个玻璃弹珠，怎样算出是玻璃弹珠掉下能碎的最小楼层

> 参考https://blog.csdn.net/u011480667/article/details/76218296

解决：每次m层尝试都是由低的楼层往高的楼层尝试，知道f(k)，第一个小球已经破掉，记录上次尝试的楼层为f(k-1)，在此楼层玻璃球不会碎，所以接下来要尝试 f(k-1)+1,f(k-1)+2,f(k-1)+3, ....直到有一层玻璃球破碎，就有解了。

转化成数学问题：假设第一次投掷的层数是f，转化成数学模型，f+(f-1)+...+2+1就表示从f开始猜，每次的增量都比前一次的增量减1的情况下，最后猜的那个数（即 f+(f-1)+...+2+1 ），按照提议要求f+(f-1)+...+2+1>=99，即f(f+1)/2>=99(第一次测试点选择100层是无意义的，必然会碎，所以无任何测试价值，所以第一次测试点k是1-99中的一个数)，解出结果等于14。丢下第一颗鸡蛋的楼层就分别是 14 ， 27 ， 39 ， 50 ， 60 ， 69 ， 77 ，84 ， 90 ， 95 ， 99 。


## 从前有座山，山脚下有5个海盗抢到了100枚金币，每一颗都一样的大小和价值。他们决定通过抽签的方式，按顺序提出分配方案决定金币的归属。 首先，由1号提出方案，5个人进行表决，半数人以上（包括半数）同意时，方案通过，否则他将被扔入大海喂鲨鱼，剩余海盗继续按顺序提出方案，依次类推。 假设每个海盗都是足够理性及机智，会考虑到利害及利益最大化问题，那么，1号海盗提出怎样的分配方案才能顺利通过考验并拿到可能性内最多的金币呢？

海盗分金推理过程：

从后向前推，如果只剩4号和5号的话，5号一定会投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号唯有支持3号才能保命。3号知道这一点，就会提(100，0，0)的分配方案，对4号、5号一毛不拔而将全部金币归为己有，因为他知道4号一无所获也会投赞成票，再加上自己一票他的方案即可通过。不过，2号推知到3号的方案，就会提出(98，0，1，1)的方案，即放弃3号，而给予4号和5号各一枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望由3号来分配。这样，2号将拿走98枚金币。不过，2号的方案会被1号所洞悉，1号并将提出(97，0，1，2，0)或(97，0，1，0，2)的方案，即放弃2号，而给3号一枚金币，同时给4号(或5号)2枚金币。由于1号的这一方案对于3号和4号(或5号)来说，相比2号分配时更优，他们将投1号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入囊中。

## 一个猴子，离他的家直线距离是50m,然后猴子旁边有100个香蕉，猴子身上最多能够背50根香蕉，猴子每走1M必须吃一根香蕉补充能量，问猴子最多能够带回家多少的香蕉？

我有100根香蕉要带回去，这里离家50米，我最多能背50根香蕉，我有强迫症，每走1米不吃一根香蕉我就不会走路，天生能吃，吃多少都撑不死。
我背50根香蕉一口气走回家？不行，到家这50根正好吃完，没香蕉我走不回来，地上这一堆我就拿不到了。
设置一个中转点吧，中转点离这里X米，背起50根香蕉出发，在中转点放下Y根香蕉带着X根香蕉返回这里正好吃完X根香蕉：**50-2X=Y**
再背起50根香蕉，走到中转点，捡起地上的Y根香蕉，回家咯！
到中转点的时候背上有**50-X**根香蕉，地上有Y根香蕉，既要让利益最大也要考虑承重限制，那么，捡起地上的香蕉后最好能有50根：**50-X+Y=50**
那么，X=Y=16.67，中转点设定在16.67米的地方。麻烦了，出余数了，取整吧，中转点距此要么16米、要么17米。
如果选16米，从这里到中转点之间的往返行动中我吃掉32根香蕉，中转点存放18根香蕉，当我再次背着50根香蕉走到中转点的时候背上有34根香蕉，扔掉2根，背着50根香蕉走到家还剩16根。
如果选17米，从这里到中转点之间的往返行动中我吃掉34根香蕉，中转点存放16根香蕉，当我再次背着50根香蕉走到中转点的时候背上有33根香蕉，捡起地上的16根香蕉，背着49根香蕉走到家还剩16根。
综上所述，作为一只没有高等智慧的猴子，我最多能带回家16根香蕉。
另外呢，我不能确定**选择一个中转点还是选择多个中转点**最终的带货量能达到最大。

## 井盖为什么是圆的

- 圆形井盖受力后，会向四周扩散压力，由于扩散均匀不容易碎裂和塌陷。
    矩形的井盖由于受力不均匀，导致碎裂的几率远大于圆形。所以通过耐用性方面考虑还是圆形井盖合适。

- 圆形井盖从任何方向都不会掉落井下，也方便操作
    矩形对角线的长度都大于矩形的长和宽。所以在对角线方向把井盖竖起来就容易掉落井下。

- 相对节省生成材料成本: 相对于矩形或者正方形，矩形内切圆形的面积最小，生成用的材料也更少。

## 在一次战争中，我方发现执行任务回归的战斗机大多机翼中弹，是否要针对性的加固机翼？

不用, 因为机尾中弹的大多飞不回来

# 场景设计题

## 设计一个限流器，限制用户一分钟只能访问3次

>  参考https://blog.csdn.net/qq_39165528/article/details/108972778

可以用redis的list来做，key为用户id，value为时间戳，然后判断是不是一分钟以内的就可以了

```lua
LUA脚本伪代码
//获取用户id
boolean allow(string userId,Long time,Long limitTime){
int size=zcard userId

if(size<100){
	zadd userId time time
	return false
}else{
	while(size>100){
	zremrangebyrank  userId 0 0 //删除头部
	}
    //开始时间
       int startTime=zrange userId 0 0;
    if（time-startTime >limitTime)）{
      return false;
        }else{
    return true;
    }

}
```

## 10亿个url, 去重, 不能一次性放入内存

分而治之

把文件分成两份a和b

Step1：遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到**1000个小文件**(记为a0,a1,...,a999，每个小文件约300M);

Step2:  遍历文件b，采取和a相同的方式将url分别存储到1000个小文件(记为b0,b1,...,b999);

　　巧妙之处：这样处理后，所有可能相同的url都被保存在对应的小文件(a0 vs b0,a1 vs b1,...,a999 vs b999)中，不对应的小文件不可能有相同的url。然后我们只要求出这个1000对小文件中相同的url即可。

Step3：求每对小文件ai和bi中相同的url: 可以把ai的url存储到hash_set中。然后遍历bi的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

## 现有海量日志数据保存在一个超级大的文件中，该文件无法直接读入内存，要求从中提取某天出访问百度次数最多的10个IP。

O(n) + O(logk)　　

Step1：从这一天的日志数据中把访问百度的IP取出来，逐个写入到一个大文件中;

　　Step2：注意到IP是32位的，最多有2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件;

　　Step3：找出每个小文中出现频率最大的10个IP(可以采用hash_map进行频率统计，然后再找出频率最大的几个)及相应的频率;

　　Step4：在这1000个最大的10个IP中，找出那个频率最大的IP，即为所求。

​	   Step4也可以维护一个大小为10的最小堆, 比堆首(最小的那个值)小的话直接不加入堆. 由此logk的复杂度得到十个最大的

## 设计题1(墨奇)

设计一个单机 KV 存储系统，存储一个*有序*的 key-value 集合（假设 key/value 都是 string）：

* 支持 get(key)、put(key, value)、delete(key) 接口
* 支持迭代器（iterator）接口
    * find(key) 返回相应 key/value 的迭代器
    * begin() 返回第一个元素的迭代器
    * iterator.next() 按照 key 的字典顺序返回集合中下一个元素的迭代器
* 需要能对内存数据进行持久化保存，重启之后数据不丢失


详细描述你的单机 KV 存储系统设计，包括：

* 在内存中使用哪种数据结构进行存储？
* 迭代器如何实现？
* 数据持久化保存的方案？
* 有多个客户端同时读写的情况如何处理？
* 其它你认为需要优化的细节？
