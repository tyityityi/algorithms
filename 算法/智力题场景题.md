# 智力题

## 100层楼，两个玻璃弹珠，怎样算出是玻璃弹珠掉下能碎的最小楼层

> 参考https://www.cnblogs.com/kuliuheng/p/11595153.html

第一次扔k层 ，则次数time=1

第二次，

- 如果破了，要试从1到k-1层，此时需要Time=time+k-1=k 次；
- 如果没破，还要扔k层，则次数为time=2;
    - 如果破了，还要扔k+1到2k-1层，再加上2 即Time=Time+k-2=k。还是K次；注意每多扔一次 少测试一层。次数却多一次。实际只要能测到n-1层就够了。

　　以此类推如果满足 k+（k-1）+（k-2）+（k-3）+（k-4）+....+2+1 >= n-1 。可以化简得到：k(k-1)>=2(n-1)

这里，n=100 所以 解得k=14。所以只要14次就可以确认那层试临界层。

## 一个猴子，离他的家直线距离是50m,然后猴子旁边有100个香蕉，猴子身上最多能够背50根香蕉，猴子每走1M必须吃一根香蕉补充能量，问猴子最多能够带回家多少的香蕉？

我有100根香蕉要带回去，这里离家50米，我最多能背50根香蕉，我有强迫症，每走1米不吃一根香蕉我就不会走路，天生能吃，吃多少都撑不死。
我背50根香蕉一口气走回家？不行，到家这50根正好吃完，没香蕉我走不回来，地上这一堆我就拿不到了。
设置一个中转点吧，中转点离这里X米，背起50根香蕉出发，在中转点放下Y根香蕉带着X根香蕉返回这里正好吃完X根香蕉：**50-2X=Y**
再背起50根香蕉，走到中转点，捡起地上的Y根香蕉，回家咯！
到中转点的时候背上有**50-X**根香蕉，地上有Y根香蕉，既要让利益最大也要考虑承重限制，那么，捡起地上的香蕉后最好能有50根：**50-X+Y=50**
那么，X=Y=16.67，中转点设定在16.67米的地方。麻烦了，出余数了，取整吧，中转点距此要么16米、要么17米。
如果选16米，从这里到中转点之间的往返行动中我吃掉32根香蕉，中转点存放18根香蕉，当我再次背着50根香蕉走到中转点的时候背上有34根香蕉，扔掉2根，背着50根香蕉走到家还剩16根。
如果选17米，从这里到中转点之间的往返行动中我吃掉34根香蕉，中转点存放16根香蕉，当我再次背着50根香蕉走到中转点的时候背上有33根香蕉，捡起地上的16根香蕉，背着49根香蕉走到家还剩16根。
综上所述，作为一只没有高等智慧的猴子，我最多能带回家16根香蕉。
另外呢，我不能确定**选择一个中转点还是选择多个中转点**最终的带货量能达到最大。

## 在一次战争中，我方发现执行任务回归的战斗机大多机翼中弹，是否要针对性的加固机翼？

不用, 因为机尾中弹的大多飞不回来

# 场景设计题

## 设计一个限流器，限制用户一分钟只能访问3次

>  参考https://blog.csdn.net/qq_39165528/article/details/108972778

可以用redis的list来做，key为用户id，value为时间戳，然后判断是不是一分钟以内的就可以了

```lua
LUA脚本伪代码
//获取用户id
boolean allow(string userId,Long time,Long limitTime){
int size=zcard userId

if(size<100){
	zadd userId time time
	return false
}else{
	while(size>100){
	zremrangebyrank  userId 0 0 //删除头部
	}
    //开始时间
       int startTime=zrange userId 0 0;
    if（time-startTime >limitTime)）{
      return false;
        }else{
    return true;
    }

}
```

