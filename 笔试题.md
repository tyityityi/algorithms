# 百度

## [21年秋招 选角色](https://www.nowcoder.com/questionTerminal/3bb34509886441bba290bcc99d76b58d)

牛牛任职于一家演艺公司，这一天，他率领着一共 n\mathit nn 个小伙伴去某知名剧组面试，在戏中，往往以戏份多少来定义角色的重要性。

 现在，这n 个小伙伴对自己都有一个定位，想要拿一个多少戏份的角色。假设将戏份多少量化，以 1～100 来衡量，那么也就是说，每个人在心中都有一个指标，自己签订的合约角色戏份绝对不能少于这个指标。

 在 n 个小伙伴都进入剧组面试之后，牛牛得到该剧组剩余 m个角色的戏份值，现在，牛牛想提前知道，对于每个人而言，一共有多少个角色是满足要求的。

##### **输入描述:**

```latex
本题为多组测试数据，第一行输入一个正整数 T(1 ≤ T ≤ 1000)\mathit T(\text 1\ \leq\ \mathit T\ \leq\ \text {1000})T(1 ≤ T ≤ 1000)，代表测试数据组数。

对于每组测试数据，第二行输入两个正整数 n, m(1 ≤ n, m ≤ 1000)\mathit n,\ \mathit m(\text 1\ \leq\ \mathit n,\ \mathit m\ \leq\ \text {1000})n, m(1 ≤ n, m ≤ 1000)，代表小伙伴数量以及剧组中角色数量。
第三行输入 n\mathit nn 个正整数 a1, a2, ..., an(1 ≤ ai ≤ 100)\mathit a_\text 1,\ \mathit a_\text 2,\ ...,\ \mathit a_\mathit n(\text 1\ \leq\ \mathit a_\mathit i\ \leq\ \text {100})a1, a2, ..., an(1 ≤ ai ≤ 100)，代表每个人心中想要找的角色在戏中最少要拥有的戏份值。
第四行输入 m\mathit mm 个正整数，b1, b2, ..., bm(1 ≤ bi ≤ 100)\mathit b_\text 1,\ \mathit b_\text 2,\ ...,\ \mathit b_\mathit m(\text 1\ \leq\ \mathit b_\mathit i\ \leq\ \text {100})b1, b2, ..., bm(1 ≤ bi ≤ 100)，代表剧组剩余的每个角色的戏份值。
```

##### **输出描述:**

```
对于每组测试数据，在一行内输出 n\mathit nn 个整数，依次代表每个小伙伴可以在剧组剩余角色中找到几个满足要求的。
```

示例1

输入

```
1
3 6
33 66 99
3 6 9 30 60 90
```

输出

```
2 1 0
```

### Solution1: 二分查找

```Java
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int numOfQ = sc.nextInt();
        //System.out.println(numOfQ);
        for(int count=0; count<numOfQ; count++){
            int numOfPerson = sc.nextInt();
            int numOfPlay = sc.nextInt();
            sc.nextLine();//下一行
            //System.out.println(numOfPerson + " "+numOfPlay);
            //String转Int[]
            int[] arrPerson=Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
            //int[] arrPerson = new int[numOfPerson];
            //for(int i=0; i<numOfPerson; i++){
            //    arrPerson[i] = sc.nextInt();
                //System.out.print(arrPerson[i]+" ");
            //}
            //System.out.println();
            int[] movies=Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
            //int[] movies = new int[numOfPlay];
            //for(int i=0; i<numOfPlay; i++){
            //    movies[i] = sc.nextInt();
                //System.out.print(score+" ");
            //}
            
            int[] result = new int[numOfPerson];
            Arrays.sort(movies);//sort之后二分查找
            for(int i=0; i<numOfPerson; i++){
                int l=0, r=movies.length-1;
                while(l<=r){
                    int mid = l+(r-l)/2;
                    if(movies[mid]<arrPerson[i])
                        l = mid+1;
                    if(movies[mid]>=arrPerson[i])
                        r = mid-1;
                }
                result[i] = movies.length-l;
            }
            //System.out.println();
            StringBuilder sb = new StringBuilder("");
            for(int i=0; i<numOfPerson; i++){
                sb.append(result[i]+" ");
            }
            sb.deleteCharAt(sb.length()-1);
            System.out.println(sb.toString());
        }
    }
}
```

### Solution2: 统计每个戏份的数量

```java
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int numOfQ = sc.nextInt();
        //System.out.println(numOfQ);
        for(int j=0; j<numOfQ; j++){
            int numOfPerson = sc.nextInt();
            int numOfPlay = sc.nextInt();
            sc.nextLine();
            int[] arrPerson=Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
            int[] movies=Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
            int[] buckets= new int[100];
            for (int value: movies){
                for(int index=0; index<value; index++){
                    buckets[index]+=1;
                }
            }
            int[] result = new int[numOfPerson];
            for(int i=0; i<numOfPerson; i++){
                int valueExpected = arrPerson[i];
                result[i] = buckets[valueExpected-1];
            }
            //System.out.println();
            StringBuilder sb = new StringBuilder("");
            for(int i=0; i<numOfPerson; i++){
                sb.append(result[i]+" ");
            }
            sb.deleteCharAt(sb.length()-1);
            System.out.println(sb.toString());
        }
    }
}
```

# 字节

## [ZJ21 特征提取](https://www.nowcoder.com/practice/5afcf93c419a4aa793e9b325d01957e2?tpId=137&&tqId=33898&rp=1&ru=/ta/exam-bytedance&qru=/ta/exam-bytedance/question-ranking)

描述

​    小明是一名算法工程师，同时也是一名铲屎官。某天，他突发奇想，想从猫咪的视频里挖掘一些猫咪的运动信息。为了提取运动信息，他需要从视频的每一帧提取“猫咪特征”。一个猫咪特征是一个两维的vector<x, y>。如果x_1=x_2 and y_1=y_2，那么这俩是同一个特征。

​    因此，如果喵咪特征连续一致，可以认为喵咪在运动。也就是说，如果特征<a, b>在持续帧里出现，那么它将构成特征运动。比如，特征<a, b>在第2/3/4/7/8帧出现，那么该特征将形成两个特征运动2-3-4 和7-8。

现在，给定每一帧的特征，特征的数量可能不一样。小明期望能找到最长的特征运动。

输入描述：

第一行包含一个正整数N，代表测试用例的个数。

每个测试用例的第一行包含一个正整数M，代表视频的帧数。

接下来的M行，每行代表一帧。其中，第一个数字是该帧的特征个数，接下来的数字是在特征的取值；比如样例输入第三行里，2代表该帧有两个猫咪特征，<1，1>和<2，2>
所有用例的输入特征总数和<100000

N满足1≤N≤100000，M满足1≤M≤10000，一帧的特征个数满足 ≤ 10000。
特征取值均为非负整数。

输出描述：

对每一个测试用例，输出特征运动的长度作为一行

示例1

输入：

```
1
8
2 1 1 2 2
2 1 1 1 4
2 1 1 2 2
2 2 2 1 4
0
0
1 1 1
1 1 1
```

复制

输出：

```
3
```

复制

说明：

```
特征<1,1>在连续的帧中连续出现3次，相比其他特征连续出现的次数大，所以输出3
```

备注：

```
如没有长度大于2的特征运动，返回1
```

### Solution

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int num = in.nextInt();
        //num组测试用例
        for(int i=0; i<num; i++){
            int max = 1;
            //记录上一行键值对的 map
            Map<String, Integer> last = new HashMap<>();
            //记录本行键值对的 map
            Map<String, Integer> temp = new HashMap<>();
            //每组测试用例总帧数
            int len = in.nextInt();
            for(int j=0; j<len; j++){
                int vec = in.nextInt();
                temp.clear();
                //每一帧的vec数
                for(int k=0; k<vec; k++){
                    String key = in.nextInt() + " " + in.nextInt();
                    temp.put(key, 1);
                }
                Set<String> lastKey = last.keySet();
                for(String key: lastKey){
                    if(temp.containsKey(key)){
                        //把上一层的有效的轨迹加到这一层
                        temp.put(key, last.get(key)+temp.get(key));
                        max = Math.max(max, temp.get(key));
                    }
                }
                last.clear();
                last.putAll(temp);
            }
            System.out.println(max);
        }
    }
}
```



## [ZJ25 头条校招](https://www.nowcoder.com/practice/57cf0b1050834901933e9b48daafbb9a?tpId=137&&tqId=34094&rp=1&ru=/ta/exam-bytedance&qru=/ta/exam-bytedance/question-ranking)

头条的2017校招开始了！为了这次校招，我们组织了一个规模宏大的出题团队，每个出题人都出了一些有趣的题目，而我们现在想把这些题目组合成若干场考试出来，在选题之前，我们对题目进行了盲审，并定出了每道题的难度系统。一场考试包含3道开放性题目，假设他们的难度从小到大分别为a,b,c，我们希望这3道题能满足下列条件：
a<=b<=c
b-a<=10
c-b<=10
所有出题人一共出了n道开放性题目。现在我们想把这n道题分布到若干场考试中（1场或多场，每道题都必须使用且只能用一次），然而由于上述条件的限制，可能有一些考试没法凑够3道题，因此出题人就需要多出一些适当难度的题目来让每场考试都达到要求，然而我们出题已经出得很累了，你能计算出我们最少还需要再出几道题吗？

输入描述：

输入的第一行包含一个整数n，表示目前已经出好的题目数量。
第二行给出每道题目的难度系数d1,d2,...,dn。
数据范围
对于30%的数据，1 ≤ n,di ≤ 5;
对于100%的数据，1 ≤ n ≤ 10^5,1 ≤ di ≤ 100。
在样例中，一种可行的方案是添加2个难度分别为20和50的题目，这样可以组合成两场考试：（20 20 23）和（35,40,50）。

输出描述：

输出只包括一行，即所求的答案。

示例1

输入：

```
4  
20 35 23 40
```

输出：

```
2
```

### Solution

```java
import java.io.BufferedInputStream;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(new BufferedInputStream(System.in));
        while(sc.hasNext()){
            sc.nextInt();
            //跳到下一行
            sc.nextLine();
            //String转Int[]
            int[] arr=Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
            Arrays.sort(arr);
            int i = 0;
            int ans = 0;
            while(i<arr.length){
                if(arr.length-i==1){//剩一题
                    ans += 2;
                    i += 1;
                } else if(arr.length-i==2){//剩两题
                    if(arr[i+1]-arr[i]<=20){//[1,8]、[1,21]都只要补一题[1,11,21]
                        ans += 1;
                    } else if(arr[i+1]-arr[i]>20){//[1, 22]需补四个拼配成[1,2,3]和[22,23,24]
                        ans += 4;
                    }
                    i += 2;
                } else {//剩大于等于三题
                    if(arr[i+1]-arr[i]<=10 && arr[i+2]-arr[i+1]<=10){//[1, 11, 21]满足
                        i += 3;
                    } else if(arr[i+1]-arr[i]<=10 && arr[i+2]-arr[i+1]>10){//[1,11,22]在11和22中间加一题，指针移到22
                        ans += 1;
                        i += 2;
                    } else {//[1,13,15]在1和13中间加入两个新题，指针移到13，使得arr剩下[13,15]，进入下一步判断（因为1 13 15 必须要加三个新题才能满足，所以这里只需要判断1和13的关系
                        ans += 2;
                        i += 1;
                    }
                }
            }
            System.out.println(ans);
        }
    }
}

```

# 美团

## [meituan-001. 小美的用户名](https://leetcode-cn.com/problems/BaR9fy/)

小美是美团的前端工程师，为了防止系统被恶意攻击，小美必须要在用户输入用户名之前做一个合法性检查，一个合法的用户名必须满足以下几个要求：

1. 用户名的首字符必须是大写或者小写字母。
2. 用户名只能包含大小写字母，数字。
3. 用户名需要包含至少一个字母和一个数字。
    如果用户名合法，请输出 "Accept"，反之输出 "Wrong"。

**格式：**

```
输入：
- 输入第一行包含一个正整数 T，表示需要检验的用户名数量。
- 接下来有 T 行，每行一个字符串 s，表示输入的用户名。
输出：
- 对于每一个输入的用户名 s，请输出一行，即按题目要求输出一个字符串。
```

**示例：**

```
输入：
     5
     Ooook
     Hhhh666
     ABCD
     Meituan
     6666
输出：
     Wrong
     Accept
     Wrong
     Wrong
     Wrong
```

**提示：**

- `1 <= T <= 100`
- s 的长度不超过 20

### Solution

```java
import java.io.*;
import java.util.*;

public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(new BufferedInputStream(System.in));
        int total = sc.nextInt();
        sc.nextLine();
        for(int i=0; i<total; i++){
            String s = sc.nextLine();
            if(isValid(s))
                System.out.println("Accept");
            else
                System.out.println("Wrong");
        }
        
    }
    private static boolean isValid(String s){
        if (s.length() <= 2) {
			return false;
		}
        //首字符
        if(!(('A'<=s.charAt(0) && s.charAt(0)<='Z')||
            ('a'<=s.charAt(0) && s.charAt(0)<='z'))){
            return false;
        }
        boolean hasLetter = false, hasNum = false;
        for(int j=0; j<s.length(); j++){
            if(('A'<=s.charAt(j) && s.charAt(j)<='Z') ||
                ('a'<=s.charAt(j) && s.charAt(j)<='z')){
                hasLetter = true;
            } else if('0'<=s.charAt(j) && s.charAt(j)<='9'){
                hasNum = true;
            } else {
                return false;
            }
        }
        return hasLetter && hasNum;
    }
}

```

## [meituan-002. 小美的仓库整理](https://leetcode-cn.com/problems/TJZLyC/)

小美是美团仓库的管理员，她会根据单据的要求按顺序取出仓库中的货物，每取出一件货物后会把剩余货物重新堆放，使得自己方便查找。已知货物入库的时候是按顺序堆放在一起的。如果小美取出其中一件货物，则会把货物所在的一堆物品以取出的货物为界分成两堆，这样可以保证货物局部的顺序不变。
已知货物最初是按 1~n 的顺序堆放的，每件货物的重量为 w[i] ,小美会根据单据依次不放回的取出货物。请问根据上述操作，小美每取出一件货物之后，重量和最大的一堆货物重量是多少？

**格式：**

```
输入：
- 输入第一行包含一个正整数 n ，表示货物的数量。
- 输入第二行包含 n 个正整数，表示 1~n 号货物的重量 w[i] 。
- 输入第三行有 n 个数，表示小美按顺序取出的货物的编号，也就是一个 1~n 的全排列。
输出：
- 输出包含 n 行，每行一个整数，表示每取出一件货物以后，对于重量和最大的一堆货物，其重量和为多少。
```

**示例：**

```
输入：
     5
     3 2 4 4 5 
     4 3 5 2 1
输出：
     9
     5
     5
     3
     0
解释：
原本的状态是 {{3,2,4,4,5}} ，取出 4 号货物后，得到 {{3,2,4},{5}} ，第一堆货物的和是 9 ，然后取出 3 号货物得到 {{3,2}{5}} ，此时第一堆和第二堆的和都是 5 ，以此类推。
```

**提示：**

- `1 <= n,m <= 50000`
- `1 <= w[i] <= 100`

### Solution

```java
import java.io.*;
import java.util.*;

public class Solution{
    public static void main(String[] args){
        Scanner sc = new Scanner(new BufferedInputStream(System.in));
        int n = sc.nextInt();
        sc.nextLine();
        int[] weights = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        int[] removeIdx = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        
        int[] prefixSum = new int[n+1];//前缀和数组，如果货物重量为[3,2,4,4,5]，则前缀和数组为[0,3,5,9,13,18]
        for(int i=1; i<n+1; i++){
            prefixSum[i] = prefixSum[i-1]+weights[i-1];
        }
    
        int[][] boundary = new int[n][2];//货物所属堆的左右边界
        for(int i=0; i<n; i++){
            boundary[i] = new int[]{-1,-1};
        }

        int[] res = new int[n];
        int max = 0;
        for(int i=n-1; i>=0; i--){
            res[i] = max;//因为是倒序，所以倒数第一次移除完的结果应为0；倒数第二次移除完的结果应为最后一个数的值

            int x = removeIdx[i] - 1;//索引从1开始
            int weight = weights[x];
            int left = x, right = x;//左边界和右边界,如果左右无连通区域则区间为[x,x],所以初始化为x
            //每次将货物的左右两块区域连成一块
            if(x+1<=n-1 && boundary[x+1][1]!=-1){//更新当前货物的右边界
                weight += prefixSum[boundary[x+1][1]+1] - prefixSum[boundary[x+1][0]];
                right = boundary[x+1][1];
            }
            if(x-1>=0 && boundary[x-1][0]!=-1){//更新当前货物的左边界
                weight += prefixSum[boundary[x-1][1]+1] - prefixSum[boundary[x-1][0]];
                left = boundary[x-1][0];
            }
            max = Math.max(max, weight);
            
            //更新两端点的左右区间
            boundary[left][0] = left;
            boundary[left][1] = right;
            boundary[right][0] = left;
            boundary[right][1] = right;
        }
        for(int i=0; i<n; i++)
            System.out.println(res[i]);
    }
}


```

