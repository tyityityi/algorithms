# 百度

## [21年秋招 选角色](https://www.nowcoder.com/questionTerminal/3bb34509886441bba290bcc99d76b58d)

牛牛任职于一家演艺公司，这一天，他率领着一共 n\mathit nn 个小伙伴去某知名剧组面试，在戏中，往往以戏份多少来定义角色的重要性。

 现在，这n 个小伙伴对自己都有一个定位，想要拿一个多少戏份的角色。假设将戏份多少量化，以 1～100 来衡量，那么也就是说，每个人在心中都有一个指标，自己签订的合约角色戏份绝对不能少于这个指标。

 在 n 个小伙伴都进入剧组面试之后，牛牛得到该剧组剩余 m个角色的戏份值，现在，牛牛想提前知道，对于每个人而言，一共有多少个角色是满足要求的。

##### **输入描述:**

```latex
本题为多组测试数据，第一行输入一个正整数 T(1 ≤ T ≤ 1000)\mathit T(\text 1\ \leq\ \mathit T\ \leq\ \text {1000})T(1 ≤ T ≤ 1000)，代表测试数据组数。

对于每组测试数据，第二行输入两个正整数 n, m(1 ≤ n, m ≤ 1000)\mathit n,\ \mathit m(\text 1\ \leq\ \mathit n,\ \mathit m\ \leq\ \text {1000})n, m(1 ≤ n, m ≤ 1000)，代表小伙伴数量以及剧组中角色数量。
第三行输入 n\mathit nn 个正整数 a1, a2, ..., an(1 ≤ ai ≤ 100)\mathit a_\text 1,\ \mathit a_\text 2,\ ...,\ \mathit a_\mathit n(\text 1\ \leq\ \mathit a_\mathit i\ \leq\ \text {100})a1, a2, ..., an(1 ≤ ai ≤ 100)，代表每个人心中想要找的角色在戏中最少要拥有的戏份值。
第四行输入 m\mathit mm 个正整数，b1, b2, ..., bm(1 ≤ bi ≤ 100)\mathit b_\text 1,\ \mathit b_\text 2,\ ...,\ \mathit b_\mathit m(\text 1\ \leq\ \mathit b_\mathit i\ \leq\ \text {100})b1, b2, ..., bm(1 ≤ bi ≤ 100)，代表剧组剩余的每个角色的戏份值。
```

##### **输出描述:**

```
对于每组测试数据，在一行内输出 n\mathit nn 个整数，依次代表每个小伙伴可以在剧组剩余角色中找到几个满足要求的。
```

示例1

输入

```
1
3 6
33 66 99
3 6 9 30 60 90
```

输出

```
2 1 0
```

### Solution1: 二分查找

```Java
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int numOfQ = sc.nextInt();
        //System.out.println(numOfQ);
        for(int count=0; count<numOfQ; count++){
            int numOfPerson = sc.nextInt();
            int numOfPlay = sc.nextInt();
            sc.nextLine();//下一行
            //System.out.println(numOfPerson + " "+numOfPlay);
            //String转Int[]
            int[] arrPerson=Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
            //int[] arrPerson = new int[numOfPerson];
            //for(int i=0; i<numOfPerson; i++){
            //    arrPerson[i] = sc.nextInt();
                //System.out.print(arrPerson[i]+" ");
            //}
            //System.out.println();
            int[] movies=Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
            //int[] movies = new int[numOfPlay];
            //for(int i=0; i<numOfPlay; i++){
            //    movies[i] = sc.nextInt();
                //System.out.print(score+" ");
            //}
            
            int[] result = new int[numOfPerson];
            Arrays.sort(movies);//sort之后二分查找
            for(int i=0; i<numOfPerson; i++){
                int l=0, r=movies.length-1;
                while(l<=r){
                    int mid = l+(r-l)/2;
                    if(movies[mid]<arrPerson[i])
                        l = mid+1;
                    if(movies[mid]>=arrPerson[i])
                        r = mid-1;
                }
                result[i] = movies.length-l;
            }
            //System.out.println();
            StringBuilder sb = new StringBuilder("");
            for(int i=0; i<numOfPerson; i++){
                sb.append(result[i]+" ");
            }
            sb.deleteCharAt(sb.length()-1);
            System.out.println(sb.toString());
        }
    }
}
```

### Solution2: 统计每个戏份的数量

```java
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int numOfQ = sc.nextInt();
        //System.out.println(numOfQ);
        for(int j=0; j<numOfQ; j++){
            int numOfPerson = sc.nextInt();
            int numOfPlay = sc.nextInt();
            sc.nextLine();
            int[] arrPerson=Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
            int[] movies=Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
            int[] buckets= new int[100];
            for (int value: movies){
                for(int index=0; index<value; index++){
                    buckets[index]+=1;
                }
            }
            int[] result = new int[numOfPerson];
            for(int i=0; i<numOfPerson; i++){
                int valueExpected = arrPerson[i];
                result[i] = buckets[valueExpected-1];
            }
            //System.out.println();
            StringBuilder sb = new StringBuilder("");
            for(int i=0; i<numOfPerson; i++){
                sb.append(result[i]+" ");
            }
            sb.deleteCharAt(sb.length()-1);
            System.out.println(sb.toString());
        }
    }
}
```

# 字节

## [ZJ25 头条校招](https://www.nowcoder.com/practice/57cf0b1050834901933e9b48daafbb9a?tpId=137&&tqId=34094&rp=1&ru=/ta/exam-bytedance&qru=/ta/exam-bytedance/question-ranking)

头条的2017校招开始了！为了这次校招，我们组织了一个规模宏大的出题团队，每个出题人都出了一些有趣的题目，而我们现在想把这些题目组合成若干场考试出来，在选题之前，我们对题目进行了盲审，并定出了每道题的难度系统。一场考试包含3道开放性题目，假设他们的难度从小到大分别为a,b,c，我们希望这3道题能满足下列条件：
a<=b<=c
b-a<=10
c-b<=10
所有出题人一共出了n道开放性题目。现在我们想把这n道题分布到若干场考试中（1场或多场，每道题都必须使用且只能用一次），然而由于上述条件的限制，可能有一些考试没法凑够3道题，因此出题人就需要多出一些适当难度的题目来让每场考试都达到要求，然而我们出题已经出得很累了，你能计算出我们最少还需要再出几道题吗？

输入描述：

输入的第一行包含一个整数n，表示目前已经出好的题目数量。
第二行给出每道题目的难度系数d1,d2,...,dn。
数据范围
对于30%的数据，1 ≤ n,di ≤ 5;
对于100%的数据，1 ≤ n ≤ 10^5,1 ≤ di ≤ 100。
在样例中，一种可行的方案是添加2个难度分别为20和50的题目，这样可以组合成两场考试：（20 20 23）和（35,40,50）。

输出描述：

输出只包括一行，即所求的答案。

示例1

输入：

```
4  
20 35 23 40
```

输出：

```
2
```

### Solution

```java
import java.io.BufferedInputStream;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(new BufferedInputStream(System.in));
        while(sc.hasNext()){
            sc.nextInt();
            //跳到下一行
            sc.nextLine();
            //String转Int[]
            int[] arr=Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
            Arrays.sort(arr);
            int i = 0;
            int ans = 0;
            while(i<arr.length){
                if(arr.length-i==1){//剩一题
                    ans += 2;
                    i += 1;
                } else if(arr.length-i==2){//剩两题
                    if(arr[i+1]-arr[i]<=20){//[1,8]、[1,21]都只要补一题[1,11,21]
                        ans += 1;
                    } else if(arr[i+1]-arr[i]>20){//[1, 22]需补四个拼配成[1,2,3]和[22,23,24]
                        ans += 4;
                    }
                    i += 2;
                } else {//剩大于等于三题
                    if(arr[i+1]-arr[i]<=10 && arr[i+2]-arr[i+1]<=10){//[1, 11, 21]满足
                        i += 3;
                    } else if(arr[i+1]-arr[i]<=10 && arr[i+2]-arr[i+1]>10){//[1,11,22]在11和22中间加一题，指针移到22
                        ans += 1;
                        i += 2;
                    } else {//[1,13,15]在1和13中间加入两个新题，指针移到13，使得arr剩下[13,15]，进入下一步判断（因为1 13 15 必须要加三个新题才能满足，所以这里只需要判断1和13的关系
                        ans += 2;
                        i += 1;
                    }
                }
            }
            System.out.println(ans);
        }
    }
}

```

